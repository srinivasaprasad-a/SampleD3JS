
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
	<link type="text/css" rel="stylesheet" href="Style.css" />
	<link type="text/css" rel="stylesheet" href="c3/c3.css" />
	<script type="text/javascript" src="d3/d3.js"></script>
	<script type="text/javascript" src="d3/d3.layout.js"></script>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script src="c3/c3.min.js"></script>
	<script type="text/javascript" src="xlsx.core.min.js"></script>
	<style type="text/css">
		.node circle {
			cursor: pointer;
			fill: #fff;
			stroke: steelblue;
			stroke-width: 1.5px;
		}
		
		.node text {
			font-size: 11px;
		}
		
		path.link {
			fill: none;
			stroke: #ccc;
			stroke-width: 1.5px;
		}
	</style>
</head>
<body>
	<div id="body" style="width: 1200; height: 100%; float: left;"></div> 
	<div id="dashboard" style="width: 400; height: 100%; text-align: left; vertical-align: top; float: right;"></div>

	<script type="text/javascript">
		/* set up XMLHttpRequest */
		var url = "EBI_Delivery FY18 Allocation.xlsx";
		var oReq = new XMLHttpRequest();
		oReq.open("GET", url, true);
		oReq.responseType = "arraybuffer";
	
		oReq.onload = function(e) {
		  var arraybuffer = oReq.response;
	
		  /* convert data to binary string */
		  var data = new Uint8Array(arraybuffer);
		  var arr = new Array();
		  for(var i = 0; i != data.length; ++i) arr[i] = String.fromCharCode(data[i]);
		  var bstr = arr.join("");
	
		  /* Call XLSX */
		  var workbook = XLSX.read(bstr, {type:"binary"});
	
		  var first_sheet_name = workbook.SheetNames[0];
		  var address_of_cell = 'A1';

		  /* Get worksheet */
		  var worksheet = workbook.Sheets[first_sheet_name];

		  /*//Find desired cell
		  var desired_cell = worksheet[address_of_cell];

		  //Get the value
		  var desired_value = (desired_cell ? desired_cell.v : undefined); */
		  
		  console.log(XLSX.utils.sheet_to_json(worksheet, {raw:true}));
		}
	
		oReq.send();
	
		//var m = [ 20, 120, 20, 120 ], w = 1280 - m[1] - m[3], h = 800 - m[0] - m[2], i = 0, root;
		var m = [ 20, 120, 20, 120 ], w = 1200 - m[1] - m[3], h = 800 - m[0] - m[2], i = 0, root;
		
		var tree = d3.layout.tree().size([ h, w ]);

		var diagonal = d3.svg.diagonal().projection(function(d) {
			return [ d.y, d.x ];
		});

		var vis = d3.select("#body").append("svg:svg").attr("width",
				w + m[1] + m[3]).attr("height", h + m[0] + m[2])
				.append("svg:g").attr("transform",
						"translate(" + m[3] + "," + m[0] + ")");

		d3.json("org_struct.json", function(json) {
			root = json;
			root.x0 = h / 2;
			root.y0 = 0;

			function toggleAll(d) {
				if (d.children) {
					d.children.forEach(toggleAll);
					toggle(d);
				}
			}

			// Initialize the display to show a few nodes.
			root.children.forEach(toggleAll);
			toggle(root.children[0]);
			/*toggle(root.children[1].children[2]);
			toggle(root.children[9]);
			toggle(root.children[9].children[0]); */

			update(root);
		});

		function update(source) {
			var duration = d3.event && d3.event.altKey ? 5000 : 500;

			// Compute the new tree layout.
			var nodes = tree.nodes(root).reverse();

			// Normalize for fixed-depth.
			nodes.forEach(function(d) {
				d.y = d.depth * 180;
			});

			// Update the nodes…
			var node = vis.selectAll("g.node").data(nodes, function(d) {
				return d.id || (d.id = ++i);
			});

			// Enter any new nodes at the parent's previous position.
			var nodeEnter = node.enter().append("svg:g").attr("class", "node")
					.attr(
							"transform",
							function(d) {
								return "translate(" + source.y0 + ","
										+ source.x0 + ")";
							}).on("click", function(d) {
						toggle(d);
						update(d);
					});

			nodeEnter.append("svg:circle").attr("r", 1e-6).style("fill",
					function(d) {
						return d._children ? "lightsteelblue" : "#fff";
					});

			nodeEnter.append("svg:text").attr("x", function(d) {
				return d.children || d._children ? -10 : 10;
			}).attr("dy", ".35em").attr("text-anchor", function(d) {
				return d.children || d._children ? "end" : "start";
			}).text(function(d) {
				return d.name;
			}).style("fill-opacity", 1e-6);

			// Transition nodes to their new position.
			var nodeUpdate = node.transition().duration(duration).attr(
					"transform", function(d) {
						return "translate(" + d.y + "," + d.x + ")";
					});

			nodeUpdate.select("circle").attr("r", 4.5).style("fill",
					function(d) {
						return d._children ? "lightsteelblue" : "#fff";
					});

			nodeUpdate.select("text").style("fill-opacity", 1);

			// Transition exiting nodes to the parent's new position.
			var nodeExit = node.exit().transition().duration(duration).attr(
					"transform", function(d) {
						return "translate(" + source.y + "," + source.x + ")";
					}).remove();

			nodeExit.select("circle").attr("r", 1e-6);

			nodeExit.select("text").style("fill-opacity", 1e-6);

			// Update the links…
			var link = vis.selectAll("path.link").data(tree.links(nodes),
					function(d) {
						return d.target.id;
					});

			// Enter any new links at the parent's previous position.
			link.enter().insert("svg:path", "g").attr("class", "link").attr(
					"d", function(d) {
						var o = {
							x : source.x0,
							y : source.y0
						};
						return diagonal({
							source : o,
							target : o
						});
					}).transition().duration(duration).attr("d", diagonal);

			// Transition links to their new position.
			link.transition().duration(duration).attr("d", diagonal);

			// Transition exiting nodes to the parent's new position.
			link.exit().transition().duration(duration).attr("d", function(d) {
				var o = {
					x : source.x,
					y : source.y
				};
				return diagonal({
					source : o,
					target : o
				});
			}).remove();

			// Stash the old positions for transition.
			nodes.forEach(function(d) {
				d.x0 = d.x;
				d.y0 = d.y;
			});
		}

		// Toggle children.
		function toggle(d) {
			if (d.children) {
				d._children = d.children;
				d.children = null;
			} else {
				d.children = d._children;
				d._children = null;
			}
		}
		
		
		
		
		var freqData=[
			{name:'May-17',freq:{low:4786, mid:1319, high:249}}
			,{name:'Jun-17',freq:{low:1101, mid:412, high:674}}
			,{name:'Jul-17',freq:{low:932, mid:2149, high:418}}
			,{name:'Aug-17',freq:{low:832, mid:1152, high:1862}}
			,{name:'Sep-17',freq:{low:4481, mid:3304, high:948}}
			,{name:'Oct-17',freq:{low:1619, mid:167, high:1063}}
			,{name:'Nov-17',freq:{low:1819, mid:247, high:1203}}
			,{name:'Dec-17',freq:{low:4498, mid:3852, high:942}}
			,{name:'Jan-18',freq:{low:797, mid:1849, high:1534}}
			];

		dashboard('#dashboard',freqData);
				
		function dashboard(id, fData){
		    var barColor = 'lightblue';
		    function segColor(c){ return {low:"#807dba", mid:"#e08214",high:"#41ab5d"}[c]; }
		    
		    // compute total for each name.
		    fData.forEach(function(d){d.total=d.freq.low+d.freq.mid+d.freq.high;});
		    
		    // function to handle histogram.
		    function histoGram(fD,xD){
		        var hG={},    hGDim = {t: 60, r: 0, b: 30, l: 0};
		        hGDim.w = 400 - hGDim.l - hGDim.r, 
		        hGDim.h = 300 - hGDim.t - hGDim.b;
		            
		        //create svg for histogram.
		        var hGsvg = d3.select(id).append("svg")
		            .attr("width", hGDim.w + hGDim.l + hGDim.r)
		            .attr("height", hGDim.h + hGDim.t + hGDim.b).append("g")
		            .attr("transform", "translate(" + hGDim.l + "," + hGDim.t + ")");

		        // create function for x-axis mapping.
		        var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1)
		                .domain(fD.map(function(d) { return d[0]; }));

		        // Add x-axis to the histogram svg.
		        hGsvg.append("g").attr("class", "x axis")
		            .attr("transform", "translate(0," + hGDim.h + ")")
		            .call(d3.svg.axis().scale(x).orient("bottom"));

		        // Create function for y-axis map.
		        var y = d3.scale.linear().range([hGDim.h, 0])
		                .domain([0, d3.max(fD, function(d) { return d[1]; })]);

		        // Create bars for histogram to contain rectangles and freq labels.
		        var bars = hGsvg.selectAll(".bar").data(fD).enter()
		                .append("g").attr("class", "bar");
		        
		        //create the rectangles.
		        bars.append("rect")
		            .attr("x", function(d) { return x(d[0]); })
		            .attr("y", function(d) { return y(d[1]); })
		            .attr("width", x.rangeBand())
		            .attr("height", function(d) { return hGDim.h - y(d[1]); })
		            .attr('fill',barColor)
		            .on("mouseover",mouseover)// mouseover is defined below.
		            .on("mouseout",mouseout);// mouseout is defined below.
		            
		        //Create the frequency labels above the rectangles.
		        /* bars.append("text").text(function(d){ return d3.format(",")(d[1])})
		            .attr("x", function(d) { return x(d[0])+x.rangeBand()/2; })
		            .attr("y", function(d) { return y(d[1])-5; })
		            .attr("text-anchor", "middle");*/
		        
		        function mouseover(d){  // utility function to be called on mouseover.
		            // filter for selected name.
		            var st = fData.filter(function(s){ return s.name == d[0];})[0],
		                nD = d3.keys(st.freq).map(function(s){ return {type:s, freq:st.freq[s]};});
		               
		            // call update functions of pie-chart and legend.    
		            /* pC.update(nD);
		            leg.update(nD); */
		        }
		        
		        function mouseout(d){    // utility function to be called on mouseout.
		            // reset the pie-chart and legend.    
		            /* pC.update(tF);
		            leg.update(tF); */
		        } 
		        
		        // create function to update the bars. This will be used by pie-chart.
		        hG.update = function(nD, color){
		            // update the domain of the y-axis map to reflect change in frequencies.
		            y.domain([0, d3.max(nD, function(d) { return d[1]; })]);
		            
		            // Attach the new data to the bars.
		            var bars = hGsvg.selectAll(".bar").data(nD);
		            
		            // transition the height and color of rectangles.
		            bars.select("rect").transition().duration(500)
		                .attr("y", function(d) {return y(d[1]); })
		                .attr("height", function(d) { return hGDim.h - y(d[1]); })
		                .attr("fill", color);

		            // transition the frequency labels location and change value.
		            bars.select("text").transition().duration(500)
		                .text(function(d){ return d3.format(",")(d[1])})
		                .attr("y", function(d) {return y(d[1])-5; });            
		        }        
		        return hG;
		    }
		    
		    // function to handle pieChart.
		    /* function pieChart(pD){
		        var pC ={},    pieDim ={w:250, h: 250};
		        pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;
		                
		        // create svg for pie chart.
		        var piesvg = d3.select(id).append("svg")
		            .attr("width", pieDim.w).attr("height", pieDim.h).append("g")
		            .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")");
		        
		        // create function to draw the arcs of the pie slices.
		        var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

		        // create a function to compute the pie slice angles.
		        var pie = d3.layout.pie().sort(null).value(function(d) { return d.freq; });

		        // Draw the pie slices.
		        piesvg.selectAll("path").data(pie(pD)).enter().append("path").attr("d", arc)
		            .each(function(d) { this._current = d; })
		            .style("fill", function(d) { return segColor(d.data.type); })
		            .on("mouseover",mouseover).on("mouseout",mouseout);

		        // create function to update pie-chart. This will be used by histogram.
		        pC.update = function(nD){
		            piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
		                .attrTween("d", arcTween);
		        }        
		        // Utility function to be called on mouseover a pie slice.
		        function mouseover(d){
		            // call the update function of histogram with new data.
		            hG.update(fData.map(function(v){ 
		                return [v.name,v.freq[d.data.type]];}),segColor(d.data.type));
		        }
		        //Utility function to be called on mouseout a pie slice.
		        function mouseout(d){
		            // call the update function of histogram with all data.
		            hG.update(fData.map(function(v){
		                return [v.name,v.total];}), 'steelblue');
		        }
		        // Animating the pie-slice requiring a custom function which specifies
		        // how the intermediate paths should be drawn.
		        function arcTween(a) {
		            var i = d3.interpolate(this._current, a);
		            this._current = i(0);
		            return function(t) { return arc(i(t));    };
		        }    
		        return pC;
		    } 
		    
		    // function to handle legend.
		    function legend(lD){
		        var leg = {};
		            
		        // create table for legend.
		        var legend = d3.select(id).append("table").attr('class','legend');
		        
		        // create one row per segment.
		        var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");
		            
		        // create the first column for each segment.
		        tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect")
		            .attr("width", '16').attr("height", '16')
					.attr("fill",function(d){ return segColor(d.type); });
		            
		        // create the second column for each segment.
		        tr.append("td").text(function(d){ return d.type;});

		        // create the third column for each segment.
		        tr.append("td").attr("class",'legendFreq')
		            .text(function(d){ return d3.format(",")(d.freq);});

		        // create the fourth column for each segment.
		        tr.append("td").attr("class",'legendPerc')
		            .text(function(d){ return getLegend(d,lD);});

		        // Utility function to be used to update the legend.
		        leg.update = function(nD){
		            // update the data attached to the row elements.
		            var l = legend.select("tbody").selectAll("tr").data(nD);

		            // update the frequencies.
		            l.select(".legendFreq").text(function(d){ return d3.format(",")(d.freq);});

		            // update the percentage column.
		            l.select(".legendPerc").text(function(d){ return getLegend(d,nD);});        
		        }
		        
		        function getLegend(d,aD){ // Utility function to compute percentage.
		            return d3.format("%")(d.freq/d3.sum(aD.map(function(v){ return v.freq; })));
		        }

		        return leg;
		    } */
		    
		    // calculate total frequency by segment for all name.
		     var tF = ['low','mid','high'].map(function(d){ 
		        return {type:d, freq: d3.sum(fData.map(function(t){ return t.freq[d];}))}; 
		    });    
		    
		    // calculate total frequency by name for all segment.
		    var sF = fData.map(function(d){return [d.name,d.total];});
		    console.log(sF);

		    var hG = histoGram(sF)/* , // create the histogram.
		        pC = pieChart(tF), // create the pie-chart.
		        leg= legend(tF) */;  // create the legend. 
		}
	</script>
</body>
</html>
